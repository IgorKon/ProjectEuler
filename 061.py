# Cyclical figurate numbers

# Problem 61
# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are 
# generated by the following formulae:

# Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
# Square	 	P4,n=n2	 	1, 4, 9, 16, 25, ...
# Pentagonal	 	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
# Hexagonal	 	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
# Heptagonal	 	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
# Octagonal	 	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...
# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

# The set is cyclic, in that the last two digits of each number is the first two digits of the next number 
# (including the last number with the first).
# Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), 
# is represented by a different number in the set.
# This is the only set of 4-digit numbers with this property.
# Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: 
# triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
# https://projecteuler.net/problem=61

import datetime
import Utilities

class PathNode:
    def __init__(self, to_partition_index, to_numbers_list):
        self.ToPortitionIndex = to_partition_index
        self.ToNumbersList = to_numbers_list
    
class Partition:
    def __init__(self, partition_index):
        self.PartitionIndex = partition_index

    def CalculateTransitions(self, SourcesDict):
        from_num_set = SourcesDict[self.PartitionIndex]
        self.FromNumToPartitionDict = dict()
        for num in from_num_set:
            num100 = num % 100
            for partition_index in SourcesDict:
                if partition_index == self.PartitionIndex:
                    continue
                other_numbers_set = SourcesDict[partition_index]
                next_list = [j for j in other_numbers_set if j // 100 == num100]
                if len(next_list) > 0:
                    if num in self.FromNumToPartitionDict.keys():
                        transitions_list = self.FromNumToPartitionDict[num]
                        transitions_list.append(PathNode(partition_index, next_list))
                    else:
                        transitions_list = list()
                        transitions_list.append(PathNode(partition_index, next_list))
                        self.FromNumToPartitionDict[num] = transitions_list

def CalculateCyclicTransitions(iStartPartition, Partitions):
    res = []
    if len(Partitions) > 0 and iStartPartition >= 0 and iStartPartition < len(Partitions):
        Partition1 = Partitions[iStartPartition]
        # iterate through all the numbers that lead somewhere from PStart partition
        for number1 in Partition1.FromNumToPartitionDict:
            # gets the list of PathNodes for that number
            pathNodeList1 = Partition1.FromNumToPartitionDict[number1]
            # iterate PathNodes for the list
            for pNode1 in pathNodeList1:
                # gets next partition for that pNode
                Partition2 = Partitions[pNode1.ToPortitionIndex]
                # iterate numbers from the list of that PathNode
                for number2 in pNode1.ToNumbersList:
                    if number2 == number1:
                        continue
                    if number2 in Partition2.FromNumToPartitionDict:
                        pathNodeList2 = Partition2.FromNumToPartitionDict[number2]
                        for pNode2 in pathNodeList2:
                            if pNode2.ToPortitionIndex == iStartPartition:
                                continue
                            # gets next partition for that pNode
                            Partition3 = Partitions[pNode2.ToPortitionIndex]
                            # iterate numbers from the list of that PathNode
                            for number3 in pNode2.ToNumbersList:
                                if number3 == number1 or number3 == number2:
                                    continue
                                if number3 in Partition3.FromNumToPartitionDict:
                                    pathNodeList3 = Partition3.FromNumToPartitionDict[number3]
                                    for pNode3 in pathNodeList3:
                                        if pNode3.ToPortitionIndex == iStartPartition or \
                                            pNode3.ToPortitionIndex == pNode1.ToPortitionIndex:
                                            continue
                                        # gets next partition for that pNode
                                        Partition4 = Partitions[pNode3.ToPortitionIndex]
                                        # iterate numbers from the list of that PathNode
                                        for number4 in pNode3.ToNumbersList:
                                            if number4 == number1 or number4 == number2 or number4 == number1:
                                                continue
                                            if number4 in Partition4.FromNumToPartitionDict:
                                                pathNodeList4 = Partition4.FromNumToPartitionDict[number4]
                                                for pNode4 in pathNodeList4:
                                                    if pNode4.ToPortitionIndex == iStartPartition or \
                                                       pNode4.ToPortitionIndex == pNode1.ToPortitionIndex or \
                                                       pNode4.ToPortitionIndex == pNode2.ToPortitionIndex:
                                                        continue
                                                    # gets next partition for that pNode
                                                    Partition5 = Partitions[pNode4.ToPortitionIndex]
                                                    # iterate numbers from the list of that PathNode
                                                    for number5 in pNode4.ToNumbersList:
                                                        if number5 == number1 or number5 == number2 or number5 == number3 or number5 == number4:
                                                            continue
                                                        if number5 in Partition5.FromNumToPartitionDict:
                                                            pathNodeList5 = Partition5.FromNumToPartitionDict[number5]
                                                            for pNode5 in pathNodeList5:
                                                                if pNode5.ToPortitionIndex == iStartPartition or \
                                                                   pNode5.ToPortitionIndex == pNode1.ToPortitionIndex or \
                                                                   pNode5.ToPortitionIndex == pNode2.ToPortitionIndex or \
                                                                   pNode5.ToPortitionIndex == pNode3.ToPortitionIndex:
                                                                    continue
                                                                # gets next partition for that pNode
                                                                Partition6 = Partitions[pNode5.ToPortitionIndex]
                                                                # iterate numbers from the list of that PathNode
                                                                for number6 in pNode5.ToNumbersList:
                                                                    if number6 == number1 or number6 == number2 or number6 == number3 or \
                                                                       number6 == number4 or number6 == number5:
                                                                        continue
                                                                    if number6 in Partition6.FromNumToPartitionDict:
                                                                        pathNodeList6 = Partition6.FromNumToPartitionDict[number6]
                                                                        for pNode6 in pathNodeList6:
                                                                            if pNode6.ToPortitionIndex == iStartPartition:
                                                                                Partition7 = Partitions[pNode6.ToPortitionIndex]
                                                                                # iterate numbers from the list of that PathNode
                                                                                for number7 in pNode6.ToNumbersList:
                                                                                    if number7 == number1:
                                                                                        res.append(number1)
                                                                                        res.append(number2)
                                                                                        res.append(number3)
                                                                                        res.append(number4)
                                                                                        res.append(number5)
                                                                                        res.append(number6)
                                                                                        return res
    return res

start_time = datetime.datetime.now()

max_i = 9999
min_i = 1000

sources = dict()
sources[0] = Utilities.TriangularNumbers(max_i, min_i)
sources[1] = Utilities.SquareNumbers(max_i, min_i)
sources[2] = Utilities.PentagonalNumbers(max_i, min_i)
sources[3] = Utilities.HexagonalNumbers(max_i, min_i)
sources[4] = Utilities.HeptagonalNumbers(max_i, min_i)
sources[5] = Utilities.OctagonalNumbers(max_i, min_i)

Partitions = list()
iCount = 0
iMinTransitionsFrom = len(sources[0])
iStartPartition = 0
for i in range(6):
    p = Partition(i)
    p.CalculateTransitions(sources)
    if len(p.FromNumToPartitionDict) > 0:
        Partitions.append(p)
        iCount += 1
        TransitionsCount = len(p.FromNumToPartitionDict)
        if iMinTransitionsFrom > TransitionsCount:
            iMinTransitionsFrom = TransitionsCount
            iStartPartition = i

res = []
if iCount == 6:
    res = CalculateCyclicTransitions(iStartPartition, Partitions)

stop_time = datetime.datetime.now()
print(stop_time - start_time)

if len(res) > 0:
    print(res)
    print(sum(res))
else:
    print('Not found')
