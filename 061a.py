# Cyclical figurate numbers

# Problem 61
# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are 
# generated by the following formulae:

# Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
# Square	 	P4,n=n2	 	1, 4, 9, 16, 25, ...
# Pentagonal	 	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
# Hexagonal	 	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
# Heptagonal	 	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
# Octagonal	 	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...
# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

# The set is cyclic, in that the last two digits of each number is the first two digits of the next number 
# (including the last number with the first).
# Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), 
# is represented by a different number in the set.
# This is the only set of 4-digit numbers with this property.
# Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: 
# triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
# https://projecteuler.net/problem=61

import datetime
import Utilities

class PathNode:
    def __init__(self, to_partition_index, to_numbers_list):
        self.ToPortitionIndex = to_partition_index
        self.ToNumbersList = to_numbers_list
    
class Partition:
    def __init__(self, partition_index):
        self.PartitionIndex = partition_index

    def CalculateTransitions(self, SourcesDict):
        from_num_set = SourcesDict[self.PartitionIndex]
        self.FromNumToPartitionDict = dict()
        for num in from_num_set:
            num100 = num % 100
            for partition_index in SourcesDict:
                if partition_index == self.PartitionIndex:
                    continue
                other_numbers_set = SourcesDict[partition_index]
                next_list = [j for j in other_numbers_set if j // 100 == num100]
                if len(next_list) > 0:
                    if num in self.FromNumToPartitionDict.keys():
                        transitions_list = self.FromNumToPartitionDict[num]
                    else:
                        transitions_list = list()
                        self.FromNumToPartitionDict[num] = transitions_list
                    transitions_list.append(PathNode(partition_index, next_list))

    def StartCyclicTransitions(self, Partitions, CycleCount):
        for number in self.FromNumToPartitionDict:
            bRes, resList = self.CalculateCyclicTransitionsStep(Partitions, CycleCount, self.PartitionIndex, number, number)
            if bRes:
                resList.insert(0, number)
                return resList
        return list()

    def CalculateCyclicTransitionsStep(self, Partitions, CycleCount, StartPartitionIndex, number, StartNumber):
        CycleCount -= 1
        if number in self.FromNumToPartitionDict:
            # gets the list of PathNodes for that number
            pathNodeList = self.FromNumToPartitionDict[number]
            # iterate PathNodes for the list
            for pNode in pathNodeList:
                # gets next partition for that pNode
                Partition = Partitions[pNode.ToPortitionIndex]
                for number1 in pNode.ToNumbersList:
                    if number1 == number:
                        continue
                    if CycleCount > 0:
                        bRes, resList = Partition.CalculateCyclicTransitionsStep(Partitions, CycleCount, StartPartitionIndex, number1, StartNumber)
                        if bRes:
                            resList.insert(0, number1)
                            return True, resList
                    else:
                    # The Last Step
                        if number1 == StartNumber:
                            return True, list()
        return False, list()

start_time = datetime.datetime.now()

max_i = 9999
min_i = 1000

sources = dict()
sources[0] = Utilities.TriangularNumbers(max_i, min_i)
sources[1] = Utilities.SquareNumbers(max_i, min_i)
sources[2] = Utilities.PentagonalNumbers(max_i, min_i)
sources[3] = Utilities.HexagonalNumbers(max_i, min_i)
sources[4] = Utilities.HeptagonalNumbers(max_i, min_i)
sources[5] = Utilities.OctagonalNumbers(max_i, min_i)

Partitions = list()
iCount = 0
iMinTransitionsFrom = len(sources[0])
iStartPartition = 0
for i in range(6):
    p = Partition(i)
    p.CalculateTransitions(sources)
    if len(p.FromNumToPartitionDict) > 0:
        Partitions.append(p)
        iCount += 1
        # finding partition with the the smallest length of Transitions to start from
        TransitionsCount = len(p.FromNumToPartitionDict)
        if iMinTransitionsFrom > TransitionsCount:
            iMinTransitionsFrom = TransitionsCount
            iStartPartition = i

res = []
if iCount == 6:
    res = Partitions[iStartPartition].StartCyclicTransitions(Partitions, 6)

stop_time = datetime.datetime.now()
print(stop_time - start_time)

if len(res) > 0:
    print(res)
    print(sum(res))
else:
    print('Not found')
